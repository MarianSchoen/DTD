% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function_mix_many_samples.R
\name{mix.samples}
\alias{mix.samples}
\title{Mix samples for loss-function learning DTD}
\usage{
mix.samples(gene.mat, pheno, included.in.X, nSamples = 1000,
  nPerMixture = 100, verbose = FALSE)
}
\arguments{
\item{gene.mat}{numeric matrix, with features as rows and samples as columns}

\item{pheno}{named vector, with pheno information for each sample in gene.mat}

\item{included.in.X}{list of strings, types that are in the reference matrix.
Only those, and sorted in that order, will be included in the quantity matrix}

\item{nSamples}{integer, numbers of samples to be drawn}

\item{nPerMixture}{integer, how many samples should be included per mixutre}

\item{verbose}{boolean, should information be printed}
}
\value{
list with random profiles, and their quantity matrix
}
\description{
mix.samples takes a gene expresssion matrix, and pheno information.
It then mixes the samples with known quantities such that it can be
used for loss-function learning digital tissue deconvolution.
}
\examples{
library(DTD)
random.data <- generate.random.data(nTypes = 10,
                                    nSamples.perType = 1e2,
                                    nFeatures = 500,
                                    sample.type = "Cell",
                                    feature.type = "gene")

# normalize all samples to the same amount of counts:
random.data <- normalizeToCount(random.data)

# extract indicator list.
# This list contains the type of the sample as value, and the sample name as names
indicator.list <- gsub("^Cell[0-9]*\\\\.", "", colnames(random.data))
names(indicator.list) <- colnames(random.data)

# extract reference matrix X
# First, decide which cells should be deconvoluted.
# Notice, in the mixtures there can be more cells than in the reference matrix.
include.in.X <- c("Type2", "Type3", "Type4", "Type5")

X.matrix <- matrix(NA, nrow=nrow(random.data), ncol=length(include.in.X))
colnames(X.matrix) <- include.in.X
rownames(X.matrix) <- rownames(random.data)

percentage.of.all.cells <- 0.2

# samples that are included in X must not be used in the training set!
samples.to.remove <- c()

for(l.type in include.in.X){
  all.of.type <- names(indicator.list)[which(indicator.list == l.type)]
  chosen.for.X <- sample(x = all.of.type,
                         size = length(all.of.type) * percentage.of.all.cells,
                         replace = FALSE)
  samples.to.remove <- c(samples.to.remove, chosen.for.X)

  average <- rowSums(random.data[, samples.to.remove])
  X.matrix[, l.type] <- average
}

train.mat <- random.data[, -which(colnames(random.data) \%in\% samples.to.remove)]
indicator.train <- indicator.list[names(indicator.list) \%in\% colnames(train.mat)]

training.data <- mix.samples(gene.mat = train.mat,
                             pheno = indicator.train,
                             included.in.X = include.in.X)

}
