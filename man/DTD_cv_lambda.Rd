% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function_crossValidation.R
\name{DTD_cv_lambda}
\alias{DTD_cv_lambda}
\title{Cross-validation for digital tissue deconvolution}
\usage{
DTD_cv_lambda(lambda.seq = NULL, nfolds = 10, lambda.length = 20,
  train.list = train, GRAD.FUN = DTD.grad.wrapper,
  EVAL.FUN = DTD.evCor.wrapper, tol = 1e-05, cv.verbose = TRUE, ...)
}
\arguments{
\item{lambda.seq}{numeric vector or NULL: Over this series of lambdas the FISTA will be optimized.
If lambda.seq is set to NULL, a generic series of lambdas - depending on the dimensions
of the training set -  will be generated}

\item{nfolds}{integer, number of buckets in the cross validation}

\item{lambda.length}{integer, how many lambdas will be generated (only used if lambda.seq is NULL)}

\item{train.list}{list, that can be passed to the GRAD.FUN and EVAL.FUN.
Within this list the train/test cross validation will be done.
Notice, that the train.list must have an entry named "mixtues". In this entry, the matrix containing the
training samples (as columns) and all features (as rows) must be present. (see Vignette for details)}

\item{GRAD.FUN}{gradient function, see \code{\link{descent_generalized_fista}}}

\item{EVAL.FUN}{evaluation function, see \code{\link{descent_generalized_fista}}}

\item{tol}{float, in each cross validation model, the function keeps track how many explaining
variables do not contribute (=> equal 0). tol is the limit until a explaining variable is
declared as "not contributing".}

\item{cv.verbose}{boolean, should information about the cv process be printed to the screen?}

\item{...}{all parameters that are passed to the \code{\link{descent_generalized_fista}} function.
E.g. maxiter, tweak_vec etc ...}
}
\value{
list of length 2. A cross validation matrix, and the model with minimal loss function
retrained on the complete dataset
}
\description{
Our descent generalized FISTA implementation includes a l1 regularization term.
This function performs a k-fold cross validation to find the best fitting regularization parameter.
}
