<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Marian Schön" />

<meta name="date" content="2018-08-17" />

<title>Loss-function learning for digital tissue deconvolution</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Loss-function learning for digital tissue deconvolution</h1>
<h4 class="author"><em>Marian Schön</em></h4>
<h4 class="date"><em>2018-08-17</em></h4>


<div id="TOC">
<ul>
<li><a href="#what-is-dtd">What is DTD?</a></li>
<li><a href="#how-to-use">How to use?</a><ul>
<li><a href="#data-generation">Data generation</a></li>
<li><a href="#data-processing">Data processing</a></li>
<li><a href="#reference-matrix-x">Reference matrix X</a></li>
<li><a href="#mixing-training-and-test-set">Mixing training and test set</a><ul>
<li><a href="#many-samples-directly">Many samples –&gt; directly</a></li>
<li><a href="#less-samples-with-jitter">Less samples –&gt; with jitter</a></li>
</ul></li>
<li><a href="#train-g-vector">Train g vector</a></li>
<li><a href="#visualize-results">Visualize results</a><ul>
<li><a href="#visualization-of-learn-curve">Visualization of learn curve</a></li>
</ul></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="what-is-dtd" class="section level1">
<h1>What is DTD?</h1>
<p>The gene expression profile of a tissue averages the expression profiles of all cells in this tissue. Digital tissue deconvolution (DTD) addresses the following inverse problem: Given the expression profile <strong>y</strong> of a tissue, what is the cellular composition <strong>c</strong> of that tissue? The theory and mathematical background of a DTD model that uses loss-function learning has been published by <span class="citation">Görtler et al. (2018)</span>. With this package we provide all necessary R functions and routines to train and use a loss-function learning digital tissue deconvolution model.</p>
The article uses the following notation. The ‘reference matrix’ is denoted as X. Every column <span class="math inline">\(X_{.,k}\)</span> is a cellular reference profile. The expression matrix of ‘bulk profiles’ is named Y. Every column <span class="math inline">\(Y_{.,k}\)</span> is a mixtures of cells, for which the quantities of the given cell profiles in X should be estimated. The standard deconvolution formula is given by
<span class="math display">\[\begin{equation}
  arg~ min_c ~|| Y_{.,k} - Xc||
\end{equation}\]</span>
<span class="citation">Görtler et al. (2018)</span> improve this formula by introducing a vector <strong>g</strong>
<span class="math display">\[\begin{equation}
  arg~ min_c ~|| diag(g) (Y_{.,k} - Xc)||
\end{equation}\]</span>
Every entry <span class="math inline">\(g_i\)</span> of g holds the information how important gene i is for the deconvolution process. The underlying idea of loss-function learning DTD is to gain the vector g by minimizing a loss function L on a training set.
<span class="math display">\[\begin{equation}
  L = - \sum_{j=1}^g cor(C_{j,.}, \widehat{C_{j,.}} (g))
\end{equation}\]</span>
<p>The training set consists of a matrix Y with bulk profiles, for which the quantities of the cells in X should be estimated. Additionally there is a matrix C. In the composition or quantity matrix C every column <span class="math inline">\(C_{.,k}\)</span> holds the distribution of the reference cells X in the bulk profile <span class="math inline">\(Y_{.,k}\)</span>. For the loss function L the correlation between the known quantities <span class="math inline">\(C_{j,.}\)</span> and the estimated quantities <span class="math inline">\(\widehat{C_{j,.}}(g)\)</span> is calculated per reference profile j.</p>
<p>In the package DTD we provide functions to generate a training and test set, and a FISTA implementation to minimize the loss function iteratively.</p>
</div>
<div id="how-to-use" class="section level1">
<h1>How to use?</h1>
<p>In the following examples, we demonstrate how data has to look like in order to be used for loss-function learning digital tissue deconvolution. After that, we give examples on how to process the data, how to generate a test and training set, how to train the g vector, and finally, how to visualize the result. First of all, load the library:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">library</span>(DTD)</code></pre></div>
<div id="data-generation" class="section level2">
<h2>Data generation</h2>
<p>The DTD package needs expression measurements of sorted cells to train a g-vector. We did not include any data in the DTD package. In order to demonstrate all functions, and to show users how the data needs to be processed, we included a <code>generate.random.data</code> function. Basically, this function has 3 key arguments:</p>
<ul>
<li>nTypes: integer, how many different types should be included in the data set.</li>
<li>nSamples.perType: integer, how many samples should be generated per type.</li>
<li>nFeatures: integer, how many features should be included.</li>
</ul>
<p>In the following we generate data consisting of 10 different cell types, with 500 features. For each cell type we generate 100 samples.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  number.types &lt;-<span class="st"> </span><span class="dv">10</span>
  random.data &lt;-<span class="st"> </span><span class="kw">generate.random.data</span>(<span class="dt">nTypes =</span> number.types, 
                                      <span class="dt">nSamples.perType =</span> <span class="dv">150</span>, 
                                      <span class="dt">nFeatures =</span> <span class="dv">250</span>)</code></pre></div>
<p>The object <code>random.data</code> is a numeric matrix with 250 rows (features), and 1500 columns (samples).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">print</span>(random.data[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])
<span class="co">#&gt;       Cell1.Type1 Cell2.Type1 Cell3.Type1 Cell4.Type1 Cell5.Type1</span>
<span class="co">#&gt; gene1           3           2           4           9           8</span>
<span class="co">#&gt; gene2           5          10          11           6           7</span>
<span class="co">#&gt; gene3           4           3           3           4           2</span>
<span class="co">#&gt; gene4           1           8           5           8           6</span>
<span class="co">#&gt; gene5           1           4           1           1           3</span>
  
  <span class="co"># for further exemplary visualization </span>
  example.index &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">151</span>, <span class="dv">301</span>, <span class="dv">451</span>)</code></pre></div>
<p>Notice that the colnames of <code>random.data</code> indicate the type of cell:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">print</span>(<span class="kw">colnames</span>(random.data)[example.index])
<span class="co">#&gt; [1] &quot;Cell1.Type1&quot;   &quot;Cell151.Type2&quot; &quot;Cell301.Type3&quot; &quot;Cell451.Type4&quot;</span></code></pre></div>
<p>Now the generated expression matrix <code>random.data</code> looks similar to expression measurements published by <span class="citation">Tirosh et al. (2016)</span> OR DO I HAVE ANY OTHER EXAMPLE. (Human cell atlas?)</p>
</div>
<div id="data-processing" class="section level2">
<h2>Data processing</h2>
<p>The first step in processing the raw expression matrix is to undo log transformation. This is necessary because our DTD approach works on an additive scale, not a multiplicative. In our case data is log2 transformed, therefore</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    random.data &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">^</span>random.data <span class="op">-</span><span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>Next, we scale every sample of the data set to a fix number of counts. Using the provided <code>normalizeToCount</code> function, every sample gets scaled such that the sum over all counts equals <span class="math inline">\(10^6\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># In random.data the number of counts differs over all samples: </span>
  <span class="kw">apply</span>(random.data, <span class="dv">2</span>, sum)[example.index]
<span class="co">#&gt;   Cell1.Type1 Cell151.Type2 Cell301.Type3 Cell451.Type4 </span>
<span class="co">#&gt;        230290        141952        141832         69328</span>
  normalized.data &lt;-<span class="st"> </span><span class="kw">normalizeToCount</span>(random.data)
  <span class="co"># In normalized.data all samples share the same number of counts: </span>
  <span class="kw">apply</span>(normalized.data, <span class="dv">2</span>, sum)[example.index]
<span class="co">#&gt;   Cell1.Type1 Cell151.Type2 Cell301.Type3 Cell451.Type4 </span>
<span class="co">#&gt;         1e+06         1e+06         1e+06         1e+06</span></code></pre></div>
<p>In addition to the normalized data matrix the DTD algorithm needs a <code>indicator.list</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> indicator.list &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^Cell[0-9]*</span><span class="ch">\\</span><span class="st">.&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="kw">colnames</span>(normalized.data))
 <span class="kw">names</span>(indicator.list) &lt;-<span class="st"> </span><span class="kw">colnames</span>(normalized.data)
 <span class="kw">print</span>(indicator.list[example.index])
<span class="co">#&gt;   Cell1.Type1 Cell151.Type2 Cell301.Type3 Cell451.Type4 </span>
<span class="co">#&gt;       &quot;Type1&quot;       &quot;Type2&quot;       &quot;Type3&quot;       &quot;Type4&quot;</span></code></pre></div>
<p><code>indicator.list</code> needs to be a named list. Each entry assigns the cell type (as value of the list) to every sample (names of the list) in the <code>normalized.data</code>.</p>
</div>
<div id="reference-matrix-x" class="section level2">
<h2>Reference matrix X</h2>
<p>Next, we select the reference matrix X. In our data set there are 10 different cell types. In this example we do not distinguish between all of them. The types we want to deconvolute are:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  include.in.X &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;Type&quot;</span>, <span class="dv">2</span><span class="op">:</span><span class="dv">7</span>)
  <span class="kw">print</span>(include.in.X)
<span class="co">#&gt; [1] &quot;Type2&quot; &quot;Type3&quot; &quot;Type4&quot; &quot;Type5&quot; &quot;Type6&quot; &quot;Type7&quot;</span></code></pre></div>
<p>For each of these types we need a reference profile <span class="math inline">\(X_{.,k}\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  X.matrix &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow=</span><span class="kw">nrow</span>(normalized.data), <span class="dt">ncol=</span><span class="kw">length</span>(include.in.X))
  <span class="kw">colnames</span>(X.matrix) &lt;-<span class="st"> </span>include.in.X
  <span class="kw">rownames</span>(X.matrix) &lt;-<span class="st"> </span><span class="kw">rownames</span>(normalized.data)</code></pre></div>
<p>For each cell type its reference profile will be calculated as the average over a fraction of all samples in the whole data set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  percentage.of.all.cells &lt;-<span class="st"> </span><span class="fl">0.2</span>
  samples.to.remove &lt;-<span class="st"> </span><span class="kw">c</span>()
  <span class="cf">for</span>(l.type <span class="cf">in</span> include.in.X){
    <span class="co"># get sample names of all cells of type &quot;l.type&quot; </span>
    all.of.type &lt;-<span class="st"> </span><span class="kw">names</span>(indicator.list)[<span class="kw">which</span>(indicator.list <span class="op">==</span><span class="st"> </span>l.type)]
    
    <span class="co"># randomly sample some cells</span>
    chosen.for.X &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> all.of.type,
                           <span class="dt">size =</span> <span class="kw">ceiling</span>(<span class="kw">length</span>(all.of.type) <span class="op">*</span><span class="st"> </span>percentage.of.all.cells),
                           <span class="dt">replace =</span> <span class="ot">FALSE</span>)
    
    <span class="co"># Add those cells which will be included in X to the list of samples.to.remove </span>
    samples.to.remove &lt;-<span class="st"> </span><span class="kw">c</span>(samples.to.remove, chosen.for.X)

    <span class="co"># for each gene average over the selected </span>
    average &lt;-<span class="st"> </span><span class="kw">rowSums</span>(normalized.data[, chosen.for.X, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
    X.matrix[, l.type] &lt;-<span class="st"> </span>average
 }</code></pre></div>
<p>Notice that every sample which has been used in the reference matrix X must not be included in the training or test set! In order to keep track of samples which must not be used furthermore we introduced the variable <code>samples.to.remove</code>. We remove all samples that have been used for generating X, and split the remaining samples into a training and a test set.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  remaining.mat &lt;-<span class="st"> </span>normalized.data[, <span class="op">-</span><span class="kw">which</span>(<span class="kw">colnames</span>(normalized.data) <span class="op">%in%</span><span class="st"> </span>samples.to.remove)]
  train.samples &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">x =</span> <span class="kw">colnames</span>(remaining.mat), 
                          <span class="dt">size =</span> <span class="kw">ceiling</span>(<span class="kw">ncol</span>(remaining.mat)<span class="op">/</span><span class="dv">2</span>), 
                          <span class="dt">replace =</span> <span class="ot">FALSE</span>)
  test.samples &lt;-<span class="st"> </span><span class="kw">colnames</span>(remaining.mat)[<span class="kw">which</span>(<span class="op">!</span><span class="kw">colnames</span>(remaining.mat) <span class="op">%in%</span><span class="st"> </span>train.samples)]
  
  train.mat &lt;-<span class="st"> </span>remaining.mat[, train.samples]
  test.mat &lt;-<span class="st"> </span>remaining.mat[, test.samples]</code></pre></div>
</div>
<div id="mixing-training-and-test-set" class="section level2">
<h2>Mixing training and test set</h2>
<p>The loss-function learning DTD algorithm trains a g-vector on a trainig set. Basically, the training set is a list of two matrices.</p>
<ul>
<li>Y, or mixtures matrix. Y has as many rows (=features) as <code>X.matrix</code> or <code>normalized.data</code>. Every column y of Y is a mixture of the cells in the data set.</li>
<li>C, or quantities matrix. C has as many rows as there are cells in <code>X.matrix</code>. Every column of C holds the distribution of the cells in each mixture of Y.</li>
</ul>
<p>In this package we provide two methods to generate the training set. One method randomly samples many cells of the complete data set, and averages over them. This is the prefered method. However, if there are only a few samples per cell type (in average below 10 samples per type) we recommend to mix samples using jitter. For both methods we provide functions within the DTD package.</p>
<div id="many-samples-directly" class="section level3">
<h3>Many samples –&gt; directly</h3>
<p>The <code>mix.samples</code> function needs the following arguments:</p>
<ul>
<li>gene.mat: numeric matrix, here <code>train.mat</code></li>
<li>pheno: named list of strings, here <code>indicator.list</code></li>
<li>included.in.X: list of strings, here include.in.X</li>
<li>nSamples: integer, how many in-silicio mixtures should be generated.</li>
<li>nPerMixture: integer, how many cells should be included in each mixture</li>
<li>verbose: boolean, should output be printed.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  indicator.train &lt;-<span class="st"> </span>indicator.list[<span class="kw">names</span>(indicator.list) <span class="op">%in%</span><span class="st"> </span><span class="kw">colnames</span>(train.mat)]
  training.data &lt;-<span class="st"> </span><span class="kw">mix.samples</span>(<span class="dt">gene.mat =</span> train.mat,
                               <span class="dt">pheno =</span> indicator.train,
                               <span class="dt">included.in.X =</span> include.in.X, 
                               <span class="dt">nSamples =</span> nSamples, 
                               <span class="dt">nPerMixture =</span> <span class="dv">100</span>, 
                               <span class="dt">verbose =</span> F)
  <span class="kw">str</span>(training.data)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ mixtures  : num [1:250, 1:500] 1559 2268 3307 2106 1867 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span>
<span class="co">#&gt;   .. ..$ : chr [1:250] &quot;gene1&quot; &quot;gene2&quot; &quot;gene3&quot; &quot;gene4&quot; ...</span>
<span class="co">#&gt;   .. ..$ : chr [1:500] &quot;mixtures1&quot; &quot;mixtures2&quot; &quot;mixtures3&quot; &quot;mixtures4&quot; ...</span>
<span class="co">#&gt;  $ quantities: num [1:6, 1:500] 0.06 0.09 0.1 0.07 0.08 0.08 0.13 0.11 0.09 0.11 ...</span>
<span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span>
<span class="co">#&gt;   .. ..$ : chr [1:6] &quot;Type2&quot; &quot;Type3&quot; &quot;Type4&quot; &quot;Type5&quot; ...</span>
<span class="co">#&gt;   .. ..$ : chr [1:500] &quot;mixtures1&quot; &quot;mixtures2&quot; &quot;mixtures3&quot; &quot;mixtures4&quot; ...</span></code></pre></div>
<p>Remark that all types are included in the mixtures, but only the distributions of the cell within the X matrix are reported in the quantities matrix. With the same function we generate a test set. Notice that a sample is only used once, either in the reference matrix X, in the test set or in the training set.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  indicator.test &lt;-<span class="st"> </span>indicator.list[<span class="kw">names</span>(indicator.list) <span class="op">%in%</span><span class="st"> </span><span class="kw">colnames</span>(test.mat)]
  test.data &lt;-<span class="st"> </span><span class="kw">mix.samples</span>(<span class="dt">gene.mat =</span> test.mat,
                           <span class="dt">pheno =</span> indicator.test,
                           <span class="dt">included.in.X =</span> include.in.X, 
                           <span class="dt">nSamples =</span> nSamples, 
                           <span class="dt">nPerMixture =</span> <span class="dv">100</span>, 
                           <span class="dt">verbose =</span> F)</code></pre></div>
</div>
<div id="less-samples-with-jitter" class="section level3">
<h3>Less samples –&gt; with jitter</h3>
<p>The <code>mix.samples.jitter</code> function needs a bit more preliminary work. It takes the following arguments:</p>
<ul>
<li>special.names: list of strings. Cell types included in the special.names list will occur with higher quantities in the mixtures</li>
<li>sample.names: list of strings. Cell types included in the sample.names list will occur with lower quantities in the mixtures</li>
</ul>
<p>The idea behind splitting all samples in the data set into <code>special.names</code> and <code>sample.names</code> is: In a tumor tissue malignant cells make up ~75% of all cells. In contrast to that, certain immune cells (e.g. a macrophage subtype) make up only ~5 % of all cells. In the training set imbalanced quantities should be reflected.</p>
<ul>
<li>nSamples: integer, how many in-silicio mixtures should be generated.</li>
<li>datamatrix: numeric matrix, here <code>train.mat</code></li>
<li>pheno: named list of strings, here <code>indicator.list</code></li>
<li>verbose: boolean, should output be printed.</li>
<li>singleSpecial: boolean, if <code>FALSE</code> all <code>special.samples</code> will be included in all mixtures, or if <code>TRUE</code> only one <code>special.sample</code> will be included per mixture. This option should be used if <code>special.samples</code> represent different tumor types.</li>
<li>add_jitter: boolean, should the mixtures be multiplied with jitter.</li>
<li>chosen.mean: numeric, mean of jitter</li>
<li>chosen.sd: numeric, standard deviation of jitter</li>
<li>min.amount.samples: integer, how many samples have to be present such that it averages over them, instad of taking only 1.</li>
<li>included.in.X: list of strings, here include.in.X</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># Here, we set &quot;Type1&quot; to be special:</span>
  special.samples &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Type1&quot;</span>)
  <span class="co"># and all other to be normal: </span>
  all.samples &lt;-<span class="st"> </span><span class="kw">unique</span>(indicator.list)
  sample.names &lt;-<span class="st"> </span>all.samples[<span class="op">-</span><span class="st"> </span><span class="kw">which</span>(all.samples <span class="op">%in%</span><span class="st"> </span>special.samples)]
  
  <span class="co"># reduce indicator list to those samples included in training: </span>
  indicator.list &lt;-<span class="st"> </span>indicator.list[<span class="kw">names</span>(indicator.list) <span class="op">%in%</span><span class="st"> </span><span class="kw">colnames</span>(train.mat)]
  
  training.data.jitter &lt;-<span class="st"> </span><span class="kw">mix.samples.jitter</span>(<span class="dt">sample.names =</span> sample.names,
                                             <span class="dt">special.samples =</span> special.samples, 
                                             <span class="dt">nSamples =</span> nSamples, 
                                             <span class="dt">datamatrix =</span> train.mat, 
                                             <span class="dt">pheno =</span> indicator.list, 
                                             <span class="dt">verbose =</span> F, 
                                             <span class="dt">add_jitter =</span> T, 
                                             <span class="dt">included.in.X =</span> include.in.X)</code></pre></div>
</div>
</div>
<div id="train-g-vector" class="section level2">
<h2>Train g vector</h2>
In the optimizing procedure we search for a vector g, which minimizes our loss function L:
<span class="math display">\[\begin{equation}
  L = - \sum_{j=1}^g cor(C_{j,.}, \widehat{C_{j,.}} (g))
\end{equation}\]</span>
<p>This optimization is done iteratively by gradient descent, using an implementation of ‘FISTA’ (Fast iterative shrinkage thresholding algorithm) <span class="citation">Beck and Teboulle (2009)</span>.</p>
<p>Our FISTA implementation takes the following arguments: - tweak_vec: numeric vector, with which the minimization starts. - maxit: integer, maximum number of iterations. - learning.rate: float, initial step size while learning. During the algorithm it may in or decreased. - F.GRAD.FUN: function with one parameter: a vector with same length as tweak_vec, and one return value with the same length. For a given vector, it returns the gradient of the loss function. - EVAL.FUN: function with one parameter: a vector with same length as tweak_vec, and a float as return value. For a given vector, it returns the value of the loss function.</p>
<p>WHY NEED OF WRAPPER</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">   <span class="co"># wrapper for gradient:</span>
   DTD.grad.wrapper &lt;-<span class="st"> </span><span class="cf">function</span>(tweak){
      X &lt;-<span class="st"> </span>X.matrix
      Y &lt;-<span class="st"> </span>training.data<span class="op">$</span>mixtures
      C &lt;-<span class="st"> </span>training.data<span class="op">$</span>quantities
      grad &lt;-<span class="st"> </span><span class="kw">Trace.H.gradient</span>(<span class="dt">X =</span> X, <span class="dt">Y =</span> Y, <span class="dt">C =</span> C, <span class="dt">tweak =</span> tweak)
      <span class="kw">return</span>(grad)
   }
  <span class="co"># wrapper for evaluation:</span>
  DTD.evCor.wrapper &lt;-<span class="st"> </span><span class="cf">function</span>(tweak){
      X &lt;-<span class="st"> </span>X.matrix
      Y &lt;-<span class="st"> </span>training.data<span class="op">$</span>mixtures
      C &lt;-<span class="st"> </span>training.data<span class="op">$</span>quantities
      loss &lt;-<span class="st"> </span><span class="kw">evaluate_cor</span>(<span class="dt">X =</span> X, <span class="dt">Y =</span> Y, <span class="dt">C =</span> C, <span class="dt">tweak =</span> tweak)
      <span class="kw">return</span>(loss)
  }</code></pre></div>
<p>Now, the optimization procedure can be started:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  start_tweak &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(X.matrix))
  catch &lt;-<span class="st"> </span><span class="kw">descent_generalized_fista</span>(<span class="dt">tweak_vec =</span> start_tweak,
                                     <span class="dt">F.GRAD.FUN =</span> DTD.grad.wrapper,
                                     <span class="dt">ST.FUN =</span> soft_thresholding,
                                     <span class="dt">FACTOR.FUN =</span> nesterov_faktor,
                                     <span class="dt">EVAL.FUN =</span> DTD.evCor.wrapper,
                                     <span class="dt">line_search_speed =</span> <span class="dv">2</span>,
                                     <span class="dt">maxit =</span> maxit,
                                     <span class="dt">save_all_tweaks =</span> T, 
                                     <span class="dt">verbose =</span> F)
  <span class="kw">str</span>(catch)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ Tweak      : num [1:250] 1.001 0.946 1.177 1.284 0.336 ...</span>
<span class="co">#&gt;  $ Convergence: num [1:250] 0.428 0.386 0.333 0.316 0.302 ...</span>
<span class="co">#&gt;  $ History    : num [1:250, 1:250] 1 1 1 1 1 1 1 1 1 1 ...</span></code></pre></div>
<p>The output of the <code>descent_generalized_fista</code> algorithm is a list. It returns the <code>tweak_vec</code> after the last iterations, and a convergence vector. Within the convergence vector there are the evaluations of the <code>EVAL.FUN</code> in every step.</p>
</div>
<div id="visualize-results" class="section level2">
<h2>Visualize results</h2>
<div id="visualization-of-learn-curve" class="section level3">
<h3>Visualization of learn curve</h3>
<p>During the training step, the algorithm finds a g-vector which minimzes the Loss-function. In order to visualize the training curve, the function <code>ggplot_correlation</code> can be used. Additionally to the output of <code>descent_generalized_fista</code> a test set and the X.matrix can be provided.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">print</span>(<span class="kw">ggplot_correlation</span>(<span class="dt">fista.output =</span> catch, 
                           <span class="dt">test.set =</span> test.data, 
                           <span class="dt">X.matrix =</span> X.matrix, 
                           <span class="dt">main =</span> <span class="st">&quot;DTD Vignette&quot;</span>))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Beck2009">
<p>Beck, Amir, and Marc Teboulle. 2009. “A Fast Iterative Shrinkage-Thresholding Algorithm for Linear Inverse Problems.” <em>SIAM Journal on Imaging Sciences</em> 2 (1). Society for Industrial &amp; Applied Mathematics (SIAM): 183–202. doi:<a href="https://doi.org/10.1137/080716542">10.1137/080716542</a>.</p>
</div>
<div id="ref-Goertler2018">
<p>Görtler, Franziska, Stefan Solbrig, Tilo Wettig, Peter J. Oefner, Rainer Spang, and Michael Altenbuchinger. 2018. <em>Research in Computational Molecular Biology: 22nd Annual International Conference, Recomb 2018, Paris, France, April 21-24, 2018, Proceedings (Lecture Notes in Computer Science)</em>. Springer.</p>
</div>
<div id="ref-Tirosh2016">
<p>Tirosh, I., B. Izar, S. M. Prakadan, M. H. Wadsworth, D. Treacy, J. J. Trombetta, A. Rotem, et al. 2016. “Dissecting the Multicellular Ecosystem of Metastatic Melanoma by Single-Cell RNA-Seq.” <em>Science</em> 352 (6282). American Association for the Advancement of Science (AAAS): 189–96. doi:<a href="https://doi.org/10.1126/science.aad0501">10.1126/science.aad0501</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
