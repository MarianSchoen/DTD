---
  title: "Loss-function learning for digital tissue deconvolution"
  author: "Marian SchÃ¶n"
  date: "`r Sys.Date()`"
  output: 
    rmarkdown::html_vignette:
      toc: TRUE
  bibliography: bibliography.bib
  vignette: >
    %\VignetteIndexEntry{Loss-function learning for digital tissue deconvolution}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r include=FALSE}
  # for fast testing 
  maxit <- 75
  nSamples <- 500
```

# What is DTD? 

The gene expression profile of a tissue averages the expression profiles of all cells in this tissue. Digital tissue deconvolution (DTD) addresses the following inverse problem: Given the expression profile __y__ of a tissue, what is the cellular composition __c__ of cells __X__ in that tissue? The theory and mathematical background of a DTD model that uses 
loss-function learning has been published by @Goertler2018. With this package we provide all necessary R functions and routines to train and use a loss-function learning digital tissue deconvolution model. 

The article uses the following notation. The _reference matrix_ is denoted as X. Every column $X_{.,k}$ is a cellular reference profile. The expression matrix of _bulk profiles_ is named Y. Every column $Y_{.,k}$ is a mixture of cells, for which the quantities $c$ of the given cell profiles in $X$ should be estimated. 
The standard deconvolution formula is given by 
\begin{equation}
  arg~ min_c ~|| Y_{.,k} - Xc|| 
\end{equation}
@Goertler2018 improve this formula by introducing a vector __g__ 
\begin{equation}
  arg~ min_c ~|| diag(g) (Y_{.,k} - Xc)|| ~~~~~~~~~~ (2)
\end{equation}
Every entry $g_i$ of g holds the information how important gene i is for the deconvolution process. The underlying idea of loss-function learning DTD is to gain the vector g by minimizing a loss function L on a training set. 
\begin{equation}
  L = - \sum_{j} cor(C_{j,.}, \widehat{C_{j,.}} (g)) + \lambda ||g||_1
\end{equation}
The training set consists of a matrix Y with bulk profiles, for which the quantities of the cells in X should be estimated. Additionally there is a matrix C. In the composition or quantity matrix C every column $C_{.,k}$ holds the distribution of the reference cells X in the bulk profile $Y_{.,k}$. For the loss function L the correlation between the known quantities $C_{j,.}$ and the estimated quantities $\widehat{C_{j,.}}(g)$ (solution of equation (2)) is calculated per reference profile j. 

In the package DTD we provide functions to generate a training and test set, and a FISTA implementation to minimize the loss function iteratively. 
```{r include=FALSE}
  # I'd like to start with 'training the g vector'. Therefore I need a lot of stuff ...
  library(DTD)
  number.types <- 20
  n.features <- 250 
  n.per.type <- 200
  nPerMixture <- 100
  random.data <- generate.random.data(nTypes = number.types, 
                                      nSamples.perType = n.per.type, 
                                      nFeatures = n.features)
  normalized.data <- normalizeToCount(random.data)
  indicator.list <- gsub("^Cell[0-9]*\\.", "", colnames(normalized.data))
  names(indicator.list) <- colnames(normalized.data)
  include.in.X <- paste0("Type", 2:5)
  X.matrix <- matrix(NA, nrow=nrow(normalized.data), ncol=length(include.in.X))
  colnames(X.matrix) <- include.in.X
  rownames(X.matrix) <- rownames(normalized.data)
  percentage.of.all.cells <- 0.1
  samples.to.remove <- c()
  for(l.type in include.in.X){
    # get sample names of all cells of type "l.type" 
    all.of.type <- names(indicator.list)[which(indicator.list == l.type)]
    
    # randomly sample some cells
    chosen.for.X <- sample(x = all.of.type,
                           size = ceiling(length(all.of.type) * percentage.of.all.cells),
                           replace = FALSE)
    
    # Add those cells which will be included in X to the list of samples.to.remove 
    samples.to.remove <- c(samples.to.remove, chosen.for.X)

    # for each gene average over the selected 
    average <- rowSums(normalized.data[, chosen.for.X, drop = FALSE])
    X.matrix[, l.type] <- average
  }
  remaining.mat <- normalized.data[, -which(colnames(normalized.data) %in% samples.to.remove)]
  train.samples <- sample(x = colnames(remaining.mat), 
                          size = ceiling(ncol(remaining.mat)/2), 
                          replace = FALSE)
  test.samples <- colnames(remaining.mat)[which(!colnames(remaining.mat) %in% train.samples)]
  
  train.mat <- remaining.mat[, train.samples]
  test.mat <- remaining.mat[, test.samples]
  indicator.train <- indicator.list[names(indicator.list) %in% colnames(train.mat)]
  training.data <- mix.samples(gene.mat = train.mat,
                               pheno = indicator.train,
                               included.in.X = include.in.X, 
                               nSamples = nSamples, 
                               nPerMixture = nPerMixture, 
                               verbose = F)
  indicator.test <- indicator.list[names(indicator.list) %in% colnames(test.mat)]
  test.data <- mix.samples(gene.mat = test.mat,
                           pheno = indicator.test,
                           included.in.X = include.in.X, 
                           nSamples = nSamples, 
                           nPerMixture = nPerMixture, 
                           verbose = F)
  # wrapper for gradient:
   DTD.grad.wrapper <- function(tweak, 
                                X = X.matrix,
                                train.list = training.data){
      Y <- train.list$mixtures
      C <- train.list$quantities
      grad <- Trace.H.gradient(X = X, Y = Y, C = C, tweak = tweak)
      return(grad)
   }
  # wrapper for evaluation:
  DTD.evCor.wrapper <- function(tweak, 
                                X = X.matrix, 
                                train.list = training.data){
      Y <- train.list$mixtures
      C <- train.list$quantities
      loss <- evaluate_cor(X = X, Y = Y, C = C, tweak = tweak)/ncol(X.matrix)
      return(loss)
  }
  start_tweak <- rep(1, nrow(X.matrix))
  start.loss <- DTD.evCor.wrapper(start_tweak)
  DTD.evCor.wrapper.test <- function(tweak, 
                              X = X.matrix, 
                              yc.list = test.data){
    Y <- yc.list$mixtures
    C <- yc.list$quantities
    loss <- evaluate_cor(X = X, Y = Y, C = C, tweak = tweak)/ncol(X.matrix)
    return(loss)
  }
```
The crucial function in the DTD package is the `descent_generalized_fista` function, which minimizes the vector g over a training set. After some preliminary work it can be called via: 
```{r, fig.width = 7, fig.align="center"}
catch <- descent_generalized_fista(tweak_vec = start_tweak,
                                   F.GRAD.FUN = DTD.grad.wrapper,
                                   ST.FUN = soft_thresholding,
                                   FACTOR.FUN = nesterov_faktor,
                                   EVAL.FUN = DTD.evCor.wrapper,
                                   NORM.FUN = n2normed, 
                                   line_search_speed = 2,
                                   maxit = maxit,
                                   save_all_tweaks = TRUE, 
                                   verbose = F)
  str(catch)
  
  print(ggplot_convergence(fista.output = catch, 
                         EVAL.FUN = DTD.evCor.wrapper.test,
                         main = "DTD Vignette"))
```

Here, we trained the g-vector for `r maxit` iterations, which decreased the loss function from `r format(max(catch$Convergence), digits = 3)` (average correlation per celltype: `r format(-max(catch$Convergence)/ncol(X.matrix), digits = 3)`) to `r format(min(catch$Convergence), digits = 3)` (average correlation per celltype: `r format(-min(catch$Convergence)/ncol(X.matrix), digits = 3)`)

# How to use? 

In the following examples, we demonstrate how data has to look like in order to be used for loss-function learning digital tissue deconvolution. After that, we give examples on how to process the data, how to generate a test and training set, how to train the g vector, and finally, how to visualize the results. 
First of all, load the library: 
```{r}
  library(DTD)
```

## Data generation 

The DTD package needs expression measurements of sorted cells to train a g-vector. We did not include any data in the DTD package. In order to demonstrate all functions, and to show users how the data needs to be processed, we included a `generate.random.data` function. The random generated data does not hold any biological information, and is only used for demonstration purpose. 
Basically, this function has 3 key arguments:

- nTypes: integer, how many different types should be included in the data set. 
- nSamples.perType: integer, how many samples should be generated per type.
- nFeatures: integer, how many features should be included.

In the following we generate data consisting of `r number.types` different cell types, with `r n.features` features. For each cell type we generate `r n.per.type` samples. 
```{r echo=FALSE, results = "asis"}
  cat("```\n")
  cat(" number.types <- " , number.types, "\n",
      "n.features <- ", n.features, "\n",
      "n.per.type <- ", n.per.type, "\n")
  cat("```\n")
```

```{r}
  random.data <- generate.random.data(nTypes = number.types, 
                                      nSamples.perType = n.per.type, 
                                      nFeatures = n.features)
```
The object `random.data` is a numeric matrix with `r nrow(random.data)` rows (features), and `r ncol(random.data)` columns (samples).
```{r}
  print(random.data[1:5, 1:5])
```
```{r include=FALSE}
  # for further exemplary visualization 
  example.index <- c(1, n.per.type + 1, 2*n.per.type + 1, 3 * n.per.type+1)
```

 Notice that the colnames of `random.data` indicate the type of the cell:
```{r}
  print(colnames(random.data)[example.index])
```

Now the generated expression matrix `random.data` looks similar to single-cell RNA sequencing data.

## Data processing 

Notice that the loss-function learning DTD approach works on an additive, not a multiplicative scale. Therefore, any log transformation or similar needs to be undone.  
Next, we scale every sample of the data set to a fix number of counts. Using the provided `normalizeToCount` function, every sample gets scaled such that the sum over all counts equals $10^6$:
```{r}
  # In random.data the number of counts differs over all samples: 
  apply(random.data, 2, sum)[example.index]
  normalized.data <- normalizeToCount(random.data)
  # In normalized.data all samples share the same number of counts: 
  apply(normalized.data, 2, sum)[example.index]
```

In addition to the normalized data matrix the DTD algorithm needs a `indicator.list`:
```{r}
 indicator.list <- gsub("^Cell[0-9]*\\.", "", colnames(normalized.data))
 names(indicator.list) <- colnames(normalized.data)
 print(indicator.list[example.index])
```
`indicator.list` needs to be a named list. Each entry assigns the cell type (as value of the list) to every sample (names of the list) in the `normalized.data`. 

## Reference matrix X

 Next, we select the reference matrix X. In our data set there are `r number.types` different cell types. In this example we do not distinguish between all of them. The types we want to deconvolute are:  
 
```{r echo=FALSE, results = "asis"}
  cat("```\n")
  cat(" include.in.X <- " , paste0("c(\"", paste(include.in.X ,collapse = "\", \""), "\")"), "\n")
  cat("```\n")
```  

For each of these types we need a reference profile $X_{.,k}$:
```{r}
  X.matrix <- matrix(NA, nrow=nrow(normalized.data), ncol=length(include.in.X))
  colnames(X.matrix) <- include.in.X
  rownames(X.matrix) <- rownames(normalized.data)
```
The reference profiles will be calculated as the average over a randomly drawn fraction of all samples in the whole data set:  

```{r echo=FALSE, results = "asis"}
  cat("```\n")
  cat(" percentage.of.all.cells <- ", percentage.of.all.cells,  "\n")
  cat("```\n")
```  

```{r}
  samples.to.remove <- c()
  for(l.type in include.in.X){
    # get sample names of all cells of type "l.type" 
    all.of.type <- names(indicator.list)[which(indicator.list == l.type)]
    
    # randomly sample some cells
    chosen.for.X <- sample(x = all.of.type,
                           size = ceiling(length(all.of.type) * percentage.of.all.cells),
                           replace = FALSE)
    
    # Add those cells which will be included in X to the list of samples.to.remove 
    samples.to.remove <- c(samples.to.remove, chosen.for.X)

    # for each gene average over the selected 
    average <- rowSums(normalized.data[, chosen.for.X, drop = FALSE])
    X.matrix[, l.type] <- average
 }
```
Notice that every sample which has been used in the reference matrix X must not be included in the training or test set! In order to keep track of samples which must not be used further on we introduced the variable `samples.to.remove`. We remove all samples that have been used for generating X, and split the remaining samples into a training and a test set.
```{r}
  # removing samples that have been used in X.matrix
  remaining.mat <- normalized.data[, -which(colnames(normalized.data) %in% samples.to.remove)]

  # sampling training samples: (notice, that train test seperation is 50:50)
  train.samples <- sample(x = colnames(remaining.mat), 
                          size = ceiling(ncol(remaining.mat)/2), 
                          replace = FALSE)
  # selecting test samples: 
  test.samples <- colnames(remaining.mat)[which(!colnames(remaining.mat) %in% train.samples)]
  
  # extract data matrices for training and testing: 
  train.mat <- remaining.mat[, train.samples]
  test.mat <- remaining.mat[, test.samples]
```


## Mixing training and test set

The loss-function learning DTD algorithm trains a g-vector on a trainig set. Basically, the training set is a list of two matrices. 

- Y, or mixtures matrix. Y has as many rows (=features) as `X.matrix` or `normalized.data`. Every column y of Y is a mixture of the cells in the data set.
- C, or quantities matrix. C has as many rows as there are cells in `X.matrix`. Every column of C holds the distribution of the cells in each mixture of Y. 

In this package we provide two methods to generate the training set. One method randomly samples many cells of the complete data set, and averages over them. This is the prefered method. However, if there are only a few samples per cell type (in average below 10 samples per type) we recommend to mix samples using jitter. For both methods we provide functions within the DTD package.

### Many samples --> directly

The `mix.samples` function needs the following arguments:

- gene.mat: numeric matrix, here `train.mat`
- pheno: named list of strings, here `indicator.list`
- included.in.X: list of strings, here include.in.X
- nSamples: integer, how many in-silicio mixtures should be generated. 
- nPerMixture: integer, how many cells should be included in each mixture
- verbose: boolean, should output be printed. 
```{r echo=FALSE, results = "asis"}
  cat("```\n")
  cat(" nSamples <- ", nSamples,  "\n",
      "nPerMixture <- ", nPerMixture,  "\n")
  cat("```\n")
```  
```{r}
  indicator.train <- indicator.list[names(indicator.list) %in% colnames(train.mat)]
  training.data <- mix.samples(gene.mat = train.mat,
                               pheno = indicator.train,
                               included.in.X = include.in.X, 
                               nSamples = nSamples, 
                               nPerMixture = nPerMixture, 
                               verbose = F)
  str(training.data)
```
Remark that all types are included in the mixtures, but only the distributions of the cell within the X matrix are reported in the quantities matrix. 
With the same function we generate a test set. Notice that a sample is only used once, either in the reference matrix X, in the test set or in the training set. 

```{r}
  indicator.test <- indicator.list[names(indicator.list) %in% colnames(test.mat)]
  test.data <- mix.samples(gene.mat = test.mat,
                           pheno = indicator.test,
                           included.in.X = include.in.X, 
                           nSamples = nSamples, 
                           nPerMixture = nPerMixture, 
                           verbose = F)
```

### Less samples --> with jitter
The `mix.samples.jitter` function needs a bit more preliminary work. 
It takes the following arguments: 

- special.names: list of strings. Cell types included in the special.names list will occur with higher quantities in the mixtures 
- sample.names: list of strings. Cell types included in the sample.names list will occur with lower quantities in the mixtures

The idea behind splitting all samples in the data set into `special.names` and `sample.names` is: 
In a tumor tissue malignant cells make up ~75% of all cells. In contrast to that, certain immune cells (e.g. a macrophage subtype) make up only ~5 % of all cells. 
In the training set imbalanced quantities should be reflected. 

- nSamples: integer, how many in-silicio mixtures should be generated. 
- datamatrix: numeric matrix, here `train.mat`
- pheno: named list of strings, here `indicator.list`
- verbose: boolean,  should output be printed. 
- singleSpecial: boolean, if `FALSE`  all `special.samples` will be included in all mixtures, or if `TRUE`  only one `special.sample` will be included per mixture. This option should be used if `special.samples` represent different tumor types. 
- add_jitter: boolean, should the mixtures be multiplied with jitter. 
- chosen.mean: numeric, mean of jitter
- chosen.sd: numeric, standard deviation of jitter
- min.amount.samples: integer, how many samples have to be present such that it averages over them, instad of taking only 1. 
- included.in.X: list of strings, here include.in.X

```{r}
  # Here, we set "Type1" to be special:
  special.samples <- c("Type1")
  # and all other to be normal: 
  all.samples <- unique(indicator.list)
  sample.names <- all.samples[- which(all.samples %in% special.samples)]
  
  # reduce indicator list to those samples included in training: 
  indicator.list <- indicator.list[names(indicator.list) %in% colnames(train.mat)]
  
  training.data.jitter <- mix.samples.jitter(sample.names = sample.names,
                                             special.samples = special.samples, 
                                             nSamples = nSamples, 
                                             datamatrix = train.mat, 
                                             pheno = indicator.list, 
                                             verbose = F, 
                                             add_jitter = T, 
                                             included.in.X = include.in.X)
```

## Train g vector

In the optimizing procedure we search for a vector g, which minimizes our loss function L: 
\begin{equation}
  L = - \sum_{j} cor(C_{j,.}, \widehat{C_{j,.}} (g)) + \lambda ||g||_1
\end{equation}
This optimization is done iteratively by gradient descent, using an implementation of 'FISTA' (Fast iterative shrinkage thresholding algorithm) @Beck2009.  
Our FISTA implementation takes the following arguments:  

- tweak_vec: numeric vector, with which the minimization starts. 
- maxit: integer, maximum number of iterations. 
- learning.rate: float, initial step size while learning. During the algorithm it may in or decrease. 
- F.GRAD.FUN: function with one parameter: a vector with same length as tweak_vec, and one return value with the same length. For a given vector, it returns the gradient of the loss function. 
- EVAL.FUN: function with one parameter: a vector with same length as tweak_vec, and a float as return value. For a given vector, it returns the value of the loss function. 

In the `descent_generalized_fista` function, the gradient function gets called with only one parameter. This parameter must be named tweak. If the gradient function takes more than one parameter, all others have to be set to default values. However, our loss function depends on 4 arguments which are the matrices C, X and Y, the tweak vector. The  matrices C, X and Y do not change during the optimization, only the tweak vector changes during optimization. In order to have a function that only depends on the tweak argument, while all others are set to default values, we advise to use wrapper function, e.g.: 
```{r}
  # wrapper for gradient:
   DTD.grad.wrapper <- function(tweak, 
                                X = X.matrix, 
                                train.list = training.data){
      Y <- train.list$mixtures 
      C <- train.list$quantities
      grad <- Trace.H.gradient(X = X, Y = Y, C = C, tweak = tweak)
      return(grad)
   }
  # wrapper for evaluation:
  DTD.evCor.wrapper <- function(tweak, 
                                X = X.matrix, 
                                train.list = training.data){
      Y <- train.list$mixtures 
      C <- train.list$quantities
      loss <- evaluate_cor(X = X, Y = Y, C = C, tweak = tweak)/ncol(X)
      return(loss)
  }
```

Now, the optimization procedure can be started: 

```{r}
  start_tweak <- rep(1, nrow(X.matrix))
  start.loss <- DTD.evCor.wrapper(start_tweak)
  cat("Start average correlation: ", -start.loss/ncol(X.matrix), "\n")
  catch <- descent_generalized_fista(tweak_vec = start_tweak,
                                     F.GRAD.FUN = DTD.grad.wrapper,
                                     ST.FUN = soft_thresholding,
                                     FACTOR.FUN = nesterov_faktor,
                                     EVAL.FUN = DTD.evCor.wrapper,
                                     line_search_speed = 2,
                                     maxit = maxit,
                                     save_all_tweaks = T, 
                                     verbose = F)
  str(catch)
```
The output of the `descent_generalized_fista` algorithm is a list. It returns the `tweak_vec` after the last iterations, and a convergence vector. Within the convergence vector there are the evaluations of the `EVAL.FUN` in every step.  

## Visualize results
### Visualization of learn curve
  During the training step, the algorithm finds a g-vector which minimzes the Loss-function. In order to visualize the training curve, the function `ggplot_correlation` can be used. 
  Additionally to the output of `descent_generalized_fista` a test set and the X.matrix can be provided.  
```{r, fig.width=5}
  DTD.evCor.wrapper.test <- function(tweak, 
                                X = X.matrix, 
                                test.list = test.data){
      Y = test.list$mixtures 
      C = test.list$quantities
      loss <- evaluate_cor(X = X, Y = Y, C = C, tweak = tweak)/ncol(X)
      return(loss)
  }
  print(ggplot_convergence(fista.output = catch, 
                           EVAL.FUN = DTD.evCor.wrapper.test,
                           main = "DTD Vignette"))
```

The trained model needs to be evaluated on the test set.  Therefore the function `ggplot_true_vs_esti` can be used. As input it takes the cell estimations of the DTD model on the test set, and the true cell compositions of the test set. In addition a `color.indi` vector can be provided
```{r, fig.width=7}
  test.estimations <- est.cs(X = X.matrix, 
                             Y = test.data$mixtures, 
                             gamma.vec = catch$Tweak
                            )
 print(ggplot_true_vs_esti(estimatedC = test.estimations,
                           trueC = test.data$quantities, 
                           norm.columnwise = FALSE)
       )
```

## Cross validation
The `descent_generalized_fista` implementation includes a l1 regularization term.
In order to find the optimal size of the regularization parameter we implemented a k-fold 
cross validation. The arguments of the `DTD_cv_lambda` function are: 

- nfolds: integer, how many buckets in the cross validation 
- lambda.seq: numeric vector or NULL. For these lambda values, models are trained. For each lambda value `nfolds` models are trained, and tested in a sense of k-fold cross validation.  If `lambda.seq` is set to NULL, a lambda sequence will be generated based on the dimension of the training set. 
- lambda.length: integer, how many lamdbas will be generated (only used if lambda.seq is NULL)
- train.list: list, that ca be passed to GRAD.FUN and EVAL.FUN. The train.list must have a entry `mixtures`. This entry must be a matrix, with training samples as columns. The cross validation folds are assigned using these column names. During the cross validation a copy of the train.list will be used, in which only samples of the current fold are present. Sample selection is done via column names for matrices, and via names for vectors.  
- GRAD.FUN: gradient function. It must expect a numeric `tweak` vector (see `descent_generalized_fista`), and an argument named `train.list`. 
- EVAL.FUN: evaluation function. It must expect a numeric `tweak` vector (see `descent_generalized_fista`), and an argument named `train.list`. 
- tol: float, after learning a model the cross validation function checks on the trained model how many coefficients are close to 0 (=> not used as explanatory variables). Instead of testing if they are equal to zero, we check if their absolute values is below `tol`. 
- ... any argument that can be passed to the `descent_generalized_fista` function (e.g. maxiter, verbose etc.)

For each fold and every lambda a model is trained. As a result the execution might be very time consuming. 
```{r}
  sequence <- 0.001*2^seq(5, -5, length.out = 10)
  set.seed(2018)
  cv.object <- DTD_cv_lambda(tweak.start = start_tweak, 
                             nfolds = 5, 
                             lambda.seq = sequence, 
                             cv.verbose = TRUE, 
                             train.list = training.data, 
                             F.GRAD.FUN = DTD.grad.wrapper, 
                             EVAL.FUN = DTD.evCor.wrapper, 
                             ST.FUN = soft_thresholding,
                             FACTOR.FUN = nesterov_faktor,
                             line_search_speed = 2,
                             maxit = maxit,
                             save_all_tweaks = FALSE, 
                             NORM.FUN = n2normed, 
                             use_restarts = TRUE,
                             verbose = FALSE
  )
  str(cv.object)
```
The return object from the `DTD_cv_lambda` function is a list with 2 entries. The `cv.obj` entries holds a data.frame with information about the cross validation over the lambda.sequence. Pass this object to the `plot.cv` function for visualization. The second entry `best.model` of the `cv.obj` is a trained model which used the lambda with minimal loss function during the cross validation. Notice that this model is trained on the complete trainings data set. This model is the output of a `descent_generalized_fista` call.
Visualize the cross validation result via:
```{r, fig.align='center'}
  print(ggplot_cv(cv.object$cv.obj))
```


# References
